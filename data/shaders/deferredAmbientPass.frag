///////////////////////////////////////////////////////////////////////////////
// Deferred Shading - Ambient + Emission Shader
// 
// This shader is part of the deferred shading pipeline. It applies ambient
// lighting and emitted (unattentuated) color of objects.
// 
// Copyright (C) 2012 Florian Nuecke
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// We use this with OpenGL 3.3 capabilities, so require shader version 3.3
#version 330
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
uniform sampler2D GBuffer0;
///////////////////////////////////////////////////////////////////////////////
// Power of ambient light (which is presumed to be white).
uniform float AmbientLightPower;
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// We get the texture coordinate on our g-buffer from the vertex shader.
in vec2 fs_TextureCoordinate;
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// We return the final color after lighting computation.
out vec3 Color;
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Main routing, does what a main does. Freakin' EVERYTHING!
void main(void) {
	vec4 tmp;
	// Get local values.
	tmp = texture2D(GBuffer0, fs_TextureCoordinate);
	vec3 diffuseAlbedo = tmp.rgb;
	float emissivity = tmp.a;

	// Apply emissive / ambient lighting.
	Color = (emissivity + AmbientLightPower) * diffuseAlbedo;
}
///////////////////////////////////////////////////////////////////////////////
